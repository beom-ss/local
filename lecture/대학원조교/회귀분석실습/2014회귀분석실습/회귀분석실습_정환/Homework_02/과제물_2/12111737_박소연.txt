/*4.3번*/

data one;
input x y;
cards;
Units	Minutes
1 	23 
2 	29 
3 	49 
4 	64 
4 	74 
5 	87 
6 	96 
6 	97 
7 	109 
8 	119 
9 	149 
9 	145 
10 	154
10 	166
11 	162
11 	174
12 	180
12 	176
14 	179
16 	193
17 	193
18 	195
18 	198
20 	205
;
run;

proc reg data=one ;
	model y =x ;
quit ;

/*(a번 )
부품의 수= x
수리시간= y
yhat=37.21273+9.96950x */

proc reg data=one ;
	model y = x / r ;
	output out=temp_01 
		p=yhat	Residual=ei  Student=ri  Cookd=Ci;
quit;
/*ri, student,cook'sd,hi, dfits 구하기*/
proc reg data=one ;
	model y = x /influence ;
	output out=temp_02
		p=yhat	Residual=ei Student=ri Cookd=cooki Rstudent=ti h=hii COVRATIO=cov DFFITS=df_fit PRESS=press ;
quit;

proc reg data=one ;
	model y = x / r influence vif ;
	ods output Outputstatistics = temp_all; 
quit;

/*관측치 번호 할당해주기*/
data temp_03 ;                 
	SET temp_02 ;
    	id = _N_ ;  
RUN; 

proc insight data=temp_03; 
run; 
/* b번 
x와 ti의 산점도를 보니 비선형성이 나타난다. 선형성의 가정에 위배된다  , 등분산성은 위배아닌거 같음*/
/*id와 ti보니 랜덤하게 흩어져 있지않고 곡선의 관계가 보임 독립성에 위배하지만, 관측개체의 취해진 순서에 큰의미가 없으므로 이는 필요하지 않다. */

/*정규성*/

proc kde data=temp_02 out=density; 
  var ti;
run;
proc sort data=density;
  by ti;
run;
goptions reset=all;
symbol1 c=blue i=join v=none height=1;
proc gplot data=density;
  plot density*ti = 1;
run; quit;
/*b번
 그래프가 선형이 아니다. , 선형의 가정 위배을 위배했다.
,등분산성은 위배되지 않았으나 , 독립성은  위배되었다.     
정규성에 위배되지 않음 */

/*4.12번*/
data work;

input y x1 x2 x3 x4 x5 x6;
cards;
443 	49 	79 	76 	8 	15 	205 
290 	27 	70 	31 	6 	6 	129 
676 	115 	92 	130 	0 	9 	339 
536 	92 	62 	92 	5 	8 	247 
481 	67 	42 	94 	16 	3 	202 
296 	31 	54 	34 	14 	11 	119 
453 	105 	60 	47 	5 	10 	212 
617 	114 	85 	84 	17 	20 	285 
514 	98 	72 	71 	12 	-1 	242 
400 	15 	59 	99 	15 	11 	174 
473 	62 	62 	81 	9 	1 	207 
157 	25 	11 	7 	9 	9 	45 
440 	45 	65 	84 	19 	13 	195 
480 	92 	75 	63 	9 	20 	232 
316 	27 	26 	82 	4 	17 	134 
530 	111 	52 	93 	11 	13 	256 
610 	78 	102 	84 	5 	7 	266 
617 	106 	87 	82 	18 	7 	276 
600 	97 	98 	71 	12 	8 	266 
480 	67 	65 	62 	13 	12 	196 
279 	38 	26 	44 	10 	8 	110 
446 	56 	32 	99 	16 	8 	188 
450 	54 	100 	50 	11 	15 	205 
335 	53 	55 	60 	8 	0 	170 
459 	61 	53 	79 	6 	5 	193 
630 	60 	108 	104 	17 	8 	273 
483 	83 	78 	71 	11 	8 	233 
617 	74 	125 	66 	16 	4 	265 
605 	89 	121 	71 	8 	8 	283 
388 	64 	30 	81 	10 	10 	176 
351 	34 	44 	65 	7 	9 	143 
366 	71 	34 	56 	8 	9 	162 
493 	88 	30 	87 	13 	0 	207 
648 	112 	105 	123 	5 	12 	340 
449 	57 	69 	72 	5 	4 	200 
340 	61 	35 	55 	13 	0 	152 
292 	29 	45 	47 	13 	13 	123 
688 	82 	105 	81 	20 	9 	268 
408 	80 	55 	61 	11 	1 	197 
461 	82 	88 	54 	14 	7 	225
;

run;
/*산점도*/
/*(a) */

proc reg data=work;
model y=x1 x2 x3 x4 x5 x6/r influence;
output out=residual_1 student=ri;
quit;

proc insight data=residual_1;
run;
/* 산점도 분석결과 크게 벗어나는 점은 없어보인다. 
그러나 cook's d 결과를 보았을 때 38번과 34번이 다른 결과값들 보다 다소 큰 것을 알 수 있었다. */    

/*(b번)
ri,ci,DFITSi*/

proc reg data=work ;
	model y = x1-x6 /influence ;
	output out=temp_02
		p=yhat	Residual=ei Student=ri Cookd=cooki Rstudent=ti h=hii COVRATIO=cov DFFITS=df_fit PRESS=press ;
quit;
/*Hi 구하기*/
data temp_03 ;
	set temp_02 ;
	di = (ei/sqrt(2.59540)) ;
    potential_Fuction = hii/(1-hii) ;
	residual_Function = ((1+1)/(1-hii))*((di*di)/(1-di*di)) ;
	hadi = potential_Fuction + residual_Function ;
run;

/* 관측치 번호 할당*/
data temp_01 ;                 
	SET temp_03 ;
    	id = _N_ ;  
RUN; 

/*c번 
index plot of ri,ci,DFITSi,Hi 구하기*/
proc insight data=temp_01;
run; 

/* Potential-Residual plot.*/
proc plot data=temp_01 ;   
plot  potential_Fuction * residual_Function /vpos=30 hpos=120 ;  
run;


/*d
plot도 그려보고 hi나 dfits등등 조사해본 결과  34번, 38번 관측치가 다른 값들과 벗어나는 것 같다.
그러나 34번, 38번 관측치의 레버리지는 특별히 이상한 점이 없었지만   잔차가  매우 크다.
따라서 34번과 38번 데이터는  outlier이다 */-