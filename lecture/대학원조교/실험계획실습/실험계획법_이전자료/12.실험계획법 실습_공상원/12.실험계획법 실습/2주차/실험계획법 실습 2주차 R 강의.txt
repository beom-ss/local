# 시작하기전 용어정리
#?객체(object): R에서의 객체는 저장된 어떤 것(a something saved)이라고 생각하면 된다. 이는 데이터일 수도 있고 함수일수도 있다. 함수의 결과를 어딘가 저장한다면, 저장된 것 또한 객체이다.
#?벡터(vector): 벡터들은 동질적이다. R 용어 정의에 따르면 같은 모드(mode)를 가지고 있어야 한다
#?행렬(matrix): 행렬은 기술적으로는 벡터이다. 즉, 행의 개수와 열의 개수라는 두 가지 속성을 추가로 갖는 벡터이다.

# 기본적인 사칙연산 및 [1]의 표시는 벡터의 첫 번째 원소라는 표시.
1+1
1-1
1*2
1/2
sqrt(4)
exp(1)
log(2, base=10)
log(2)
log(2, base=exp(1))

# 도움말 검색방법
?print
help(matrix)
help("lm")

# 기본적인 벡터 및 문자 입력하고 출력하기
x<-c(1, 2, 3)
y<-c("Tim", "Ann", "태연", "하니")
x
y
print(x) ; print(y)

print(x)
print(y)

# 작업공간 변수목록 보기 지우기, 전체지우기
x<-c(1, 2, 3)
y<-c(10, 100, 100)
z<-c("A", "B", "C")
ls()
rm(x)
ls()
rm(list=ls()) # 단 이코드는 다른사람들과 공유할때 넣으면 안된다. 이 명령어를 통해 다른사람의 작업공간에 있는 벼 ㄴ수들을 모두 삭제하는 행동은 무례함의 정도를 넘어서는 짓이기 때문이다. 기본적인 예의를 지키자
ls()

# 벡터만들기
# C(..)연산자를 사용해서 주어진 값으로부터 벡터를 구한다.

c(1,1,1,2,2,2,3,3,3,10,20,100)
c(1*pi, 2*pi, 3*pi)
c("L", "O", "V", "E")
c(TRUE, TRUE, FALSE, TRUE)

# object명 주기
x<-c(1,1,1,2,2,2,3,3,3,10,20,100)
y<-c(1*pi, 2*pi, 3*pi)
z<-c("L", "O", "V", "E")
a<-c(TRUE, TRUE, FALSE, TRUE)
x;y;z;a

# 벡터끼리 풀어서 하나로 합치기
c(x,y)
b<-c(x,y)
b

# 벡터는 숫자와 문자열 같이 데이터 형식을 섞어서를 만들수 없다.
x<-c(1,1,1,2,2,2,3,3,3,10,20,100)
z<-c("L", "O", "V", "E")
c(x, z) # 데이터 원소가 모두 호환되게 숫자를 문자로 바꿧다.

# 수치형인지 문자형인지 확인하기
mode(pi)
mode(3.1415)
mode("Man")

c(3.1415, "Man")

# 기본적인 통계량 계산하기
x<-c(0, 1, 1, 2, 3, 5, 8, 13, 21, 34)
mean(x) # 평균
median(x) # 중앙값
sd(x) # 표준편차
var(x) # 중앙값
range(x) # 범위
quantile(x) # 사분위수
length(x) # 길이
sum(x) # 합
min(x) # 최소값
max(x) # 최대값


y<-log(x+1) # x벡터를 이용해서 하나의 식으로 새로운 벡터를 만들 수 있다.
cor(x,y) # 상관계수 계산
cov(x,y) # 공분산 계산

# 결측치 해결하기
# R은 결측치에 대해 까다롭게 군다.
x<-c(0,1,1,2,3,NA)
mean(x)
sd(x)
# 이때 상황별로 신중하게 판단해야 하기 때문에 만약 옳게 처리한 것이라면 NA를 무시하고 활용하는 방법
x<-c(0,1,1,2,3,NA)
mean(x, na.rm=TRUE) ; mean(c(0,1,1,2,3))
sd(x, na.rm=TRUE) ; sd(c(0,1,1,2,3))
# 다시 정리하자면 R에서 존재하지 않는 값으로 NA와 NULL이 있다. NA의 용도 중 하나는 결측값을 표시할 때 쓰는 것이며, NULL의 용도 중 하나는 반복문에서 매번 원소를 추가해가며 벡터를 생성할 때 쓰는 것이다.
x <- c(88, NA, 12, 168, 13)
x
mean(x)  # NA값 때문에 계산을 거부한다.
mean(x, na.rm=TRUE)  # R의 많은 통계 함수에서 누락된 값이나 NA는 건너뛰고 실행되도록 할 수 있다.
x <- c(88, NULL, 12, 168, 13)  # NULL 값은 자동으로 넘어간다.
x
mean(x)

# 새로운 값으로 대체하기 위한 빈방 작업
x <- NULL
for(i in 1:10){
  x <- c(x, i)  # x를 NULL로 만든다음, 새로운 값(i=1,2,..10)을 추가
}
x

x <- rep(0, 10)
for(i in 1:10){
  x[i] <- i  # x를 10개의 0을 가진 벡터로 만든 다음, 새로운 값을 추가(위와 동일)
}
x

# R에서 제공하는 연습용 Data Set 보기
data() # Data Set보는 방법
x<-iris
dim(x) # data수, 변수수
fix(x) # 전체 데이터를 보여줌
head(x) # 전체 데이터에서 6개만 보여줌
mean(x$Sepal.Length)
max(x$Sepal.Width)
median(x$Petal.Length)
mean(x$Petal.Width)
table(x$Species) # 빈도 테이블 (빈도표)
summary(x)

# 수열 생성
1:5
5:1
seq(1,5)
seq(1,5,2) #seq(from=, to=, by=) from 부터 to 까지 by단위로 증가
seq(from=1, to=5, by=2)
rep(1, 10) # rep(값, times=) 값을 times만큼 반복
rep(c(1,3,5),each=5,5) # rep 값을 each(각각) tines만큼 반복
# 수열 생성 응용
x<-c(1,2,3)
rep(x,3)
rep(c(1,2,3),3)
rep(seq(1,5,2),3)

# 논리 연산자
a<-3
a == pi # 값이 같은지 검사 ==
a != pi # 값이 다른지 검사 !=
a < pi
a > pi
a <= pi
a >= pi

# 벡터끼리 논리연산자
x<-c(3, pi, 4)
y<-c(pi, pi, pi)

x == y
x != y
x < y
x > y
x <= y
x >= y

# 하나의 벡터와 비교
x<-c(3, pi, 4)
x == pi
x != pi

# 인덱싱(indexing) 특정 위치 찾기 # 필터링(filtering) 특정 조건을 만족하는 원소만 가져오기
set.seed(1234)
y <- rnorm(n=5, mean=0, sd=1)  # 표준정규분포의 난수 5개를 생성
y
y[1] # y의 첫번째 원소
y[c(1,3)] # y의 첫번째 세번째 원소
y[c(-1)] ; y[-c(1)] # y의 첫번째 원소 제거
index<-c(1:3)
y[index]
y[-index]
y > 0
y[y > 0] # y>0인 원소만 가져옴
subset(y, y>0) # y>0인것만 가져옴 , 응용 예제 subset(airquality, Temp > 80, select = c(Ozone, Temp)) 

# 벡터연산
x<-c(10, 20, 30, 40, 50)
y<-c(1, 2, 3, 4, 5)

x+y
x-y
x*y
x/y
x^2
x^y

x+1
x-1
x*2
x/10
x^2 ; x**2
x^3 ; x**3
2^x

x<-c(1,2,3,4,5)
mean(x)
x-mean(x)
sum(x-mean(x))
x-mean(x)/sd(x)

x%*%y # 행렬곱셈

# 행렬
y <- matrix(c(1,2,3,4), nrow=2, ncol=2)  # 열 단위로 데이터를 입력 후, (2 x 2) matrix를 생성
y

y <- matrix(c(1,2,3,4), nrow=2, ncol=2, byrow=TRUE)  # 열 단위로 데이터를 입력 후, (2 x 2) matrix를 생성
y

nrow(y) # 행의 수
ncol(y) # 열의 수

length(y) # 행의수 * 열의 수 가 나온다.

y+y
y-y
y*3
y/10
y%*%y
t(y) # 전치

# 행열의 인덱싱과 필터링
y <- matrix(rep(c(1,2), 3) + rep(c(10, 20, 30), each=2), ncol=2, byrow=T)
y

y[,2]  # 3번째 열 추출
y[1,]  # 1번째 행 추출
y[1,2]  # 행렬의 (1,2) 원소 추출
y[y[,2] > 20, ]  # 두번째 열의 값이 20이상인 행을 추출 즉, 행으로 자료를 뽑는데 그 기준이 열로 만드는 작업
z <- y[y[,2] > 20, ]  # 이 경우에는 여전히 부분집합이 행렬이다.
attributes(z) # 행렬 속성

colMeans(y)  # 열 평균
colSums(y)  # 열 합
rowMeans(y)  # 행 평균
rowSums(y)  #행 합

# 행렬의 함수 적용하기 apply 함수 이용
apply(m, dimcode, f, fargs)
?m은 행렬이다.
?dimcode는 차원수로, 1인 경우 함수를 행에 적용하고 2인 경우 열에 적용한다.
?f는 적용할 함수로, 사용자가 직접 만들어도 된다.
?fargs는 f에 필요한 인수의 집합으로 선택사항이다.

y <- matrix(rep(c(1,2), 3) + rep(c(10, 20, 30), each=2), ncol=2, byrow=T)
y

apply(y, 2, mean)  # 열 평균
apply(y, 1, mean)  # 행 평균

# 행렬 추가하기
set.seed(1) # 같은 결과를 위해 seed 고정
x1 <- runif(n=10, min=0, max=2) # 유니폼 난수
x2 <- rpois(n=10, lambda=10) # 포아송 난수
x3 <- rnorm(n=10, mean=0, sd=1) # 정규분포 난수
cbind(x1, x2)
cbind(cbind(x1, x2), x3)

x4<-c(1,2,3,4,5) # col같은 경우 반복이 된다.
cbind(cbind(x1, x2), x3, x4)

newx <- c(1,2,3)
rbind(cbind(x1, x2, x3), newx)

newx <- c(1,2,NA)
rbind(cbind(x1, x2, x3), newx)

newx <- c(1,2) # row는 오류가 나온다.
rbind(cbind(x1, x2, x3), newx)

Xmat <- rbind(cbind(x1, x2, x3), newx)
Xmat
dimnames(Xmat)  # 행 이름, 열 이름 보기

colnames(Xmat) <- paste("PREDICTOR", 1:3, sep="")  # 열 이름 주기
rownames(Xmat) <- 1:nrow(Xmat)  # 행 이름 주기
Xmat

dimnames(Xmat) <- NULL  # 행렬 이름 초기화
Xmat

dimnames(Xmat) <- list(1:nrow(Xmat), paste("PREDICTOR", 1:3, sep=""))  # 첫번째 인수가 행이름, 두번째 인수가 열 이름
Xmat

# 고차원 배열
# 행렬이 2차원 구조이면 배열은 3차원 이상의 구조이다. R에서의 배열은 이러한 고차원 구조를 말한다. 간단한 예로 학생 2명에 대한 3개 과목의 시험 성적(중간, 기말)을 예로 들어보자. 배열은 주로 표를 계산할 때 사용된다.

test1 <- matrix(c(46,30, 21,25, 50,50), ncol=2, byrow=T)
test2 <- matrix(c(46,43, 41,35, 50,50), ncol=2, byrow=T)

test1
test2

tests <- array(data=c(test1, test2), dim=c(3, 2, 2))
tests

dimnames(tests) <- list(c("A", "B", "C"), c("mid", "final"), c("student1", "student2"))
tests

# 설치된 패키지 목록 보기
library() # 설치된 패키지 보기
installed.packages()[,c("Package", "Version")] # 설치된 패키지 이름과 버전 확인

# dataframe
# sort
# list
# library
# pakacges
# if
# for
